commit 71409184dc00604537ce03312dc17ba986c329d9
Merge: 6d43fef 0332ee9
Author: bors <bors@rust-lang.org>
Date:   Sun Nov 1 17:15:29 2015 +0000

    Auto merge of #29177 - vadimcn:rtstuff, r=alexcrichton
    
    Note: for now, this change only affects `-windows-gnu` builds.
    
    So why was this `libgcc` dylib dependency needed in the first place?
    The stack unwinder needs to know about locations of unwind tables of all the modules loaded in the current process.  The easiest portable way of achieving this is to have each module register itself with the unwinder when loaded into the process.  All modules compiled by GCC do this by calling the __register_frame_info() in their startup code (that's `crtbegin.o` and `crtend.o`, which are automatically linked into any gcc output).
    Another important piece is that there should be only one copy of the unwinder (and thus unwind tables registry) in the process.  This pretty much means that the unwinder must be in a shared library (unless everything is statically linked).
    
    Now, Rust compiler tries very hard to make sure that any given Rust crate appears in the final output just once.   So if we link the unwinder statically to one of Rust's crates, everything should be fine.
    
    Unfortunately, GCC startup objects are built under assumption that `libgcc` is the one true place for the unwind info registry, so I couldn't find any better way than to replace them.  So out go `crtbegin`/`crtend`, in come `rsbegin`/`rsend`!
    
    A side benefit of this change is that rustc is now more in control of the command line that goes to the linker, so we could stop using `gcc` as the linker driver and just invoke `ld` directly.
rustc: ./html5ever-2015-05-15
cargo rustc -- -Ztime-passes
   Compiling html5ever_macros v0.0.0 (file:///root/benchmarks/html5ever-2015-05-15)
   Compiling serde v0.6.1
Build failed, waiting for other jobs to finish...
makefile:2: recipe for target 'all' failed
done
